<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ISS Flyover Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root {
      color-scheme: dark;
      --bg: #06080f;
      --panel: rgba(14, 20, 36, 0.82);
      --panel-strong: rgba(16, 24, 44, 0.92);
      --text: #e6edf6;
      --muted: #9aa7bc;
      --accent: #2ad1ff;
      --accent-2: #9b5cff;
      --accent-3: #17f1b1;
      --warning: #ffb452;
      --danger: #ff6b6b;
      --success: #6bffb2;
      --border: rgba(120, 140, 180, 0.2);
      --shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(33, 49, 83, 0.6), transparent 45%),
        radial-gradient(circle at 20% 30%, rgba(43, 143, 187, 0.25), transparent 50%),
        linear-gradient(140deg, #05060a 0%, #0b1020 45%, #05060a 100%);
      color: var(--text);
      font-family: "Space Grotesk", sans-serif;
      letter-spacing: 0.02em;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image:
        radial-gradient(2px 2px at 20px 30px, rgba(255, 255, 255, 0.3), transparent 40%),
        radial-gradient(1px 1px at 120px 80px, rgba(255, 255, 255, 0.25), transparent 40%),
        radial-gradient(1.5px 1.5px at 250px 160px, rgba(255, 255, 255, 0.2), transparent 40%),
        radial-gradient(2px 2px at 70% 20%, rgba(255, 255, 255, 0.2), transparent 40%),
        radial-gradient(1px 1px at 80% 80%, rgba(255, 255, 255, 0.15), transparent 40%);
      opacity: 0.4;
      pointer-events: none;
      z-index: 0;
    }

    .app {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 28px clamp(20px, 4vw, 48px) 48px;
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    h1 {
      font-size: clamp(2rem, 2vw + 1.6rem, 3rem);
      margin: 0;
      letter-spacing: 0.04em;
    }

    .subtitle {
      color: var(--muted);
      font-size: 0.98rem;
      margin: 0;
      max-width: 700px;
    }

    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: rgba(40, 52, 80, 0.7);
      border: 1px solid rgba(120, 140, 180, 0.25);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 999px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: transform 0.2s ease, border 0.2s ease, background 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      border-color: rgba(42, 209, 255, 0.6);
      background: rgba(36, 56, 92, 0.9);
    }

    button.primary {
      background: linear-gradient(135deg, rgba(42, 209, 255, 0.3), rgba(155, 92, 255, 0.4));
      border-color: rgba(42, 209, 255, 0.6);
    }

    button.active {
      background: linear-gradient(135deg, rgba(42, 209, 255, 0.4), rgba(23, 241, 177, 0.2));
      border-color: rgba(23, 241, 177, 0.7);
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 16px 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .card h3 {
      margin: 0 0 10px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted);
    }

    .stat-value {
      font-family: "IBM Plex Mono", monospace;
      font-size: 1.05rem;
      letter-spacing: 0.08em;
    }

    .stat-sub {
      color: var(--muted);
      font-size: 0.82rem;
      margin-top: 6px;
    }

    .view-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .view-toggle {
      display: inline-flex;
      gap: 8px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(10, 16, 30, 0.7);
      border: 1px solid var(--border);
      width: fit-content;
    }

    .viewer {
      position: relative;
      background: var(--panel-strong);
      border: 1px solid var(--border);
      border-radius: 26px;
      min-height: 460px;
      overflow: hidden;
      box-shadow: var(--shadow);
      overscroll-behavior: contain;
    }

    .view-panel {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .view-panel.active {
      opacity: 1;
      pointer-events: auto;
    }

    #map {
      z-index: 1;
      background: var(--map-bg, #1a2940);
    }

    #map.leaflet-container,
    #map .leaflet-container {
      background: var(--map-bg, #1a2940);
      touch-action: none;
    }

    #map.map-theme-primary .leaflet-tile {
      filter: var(--map-tile-filter-primary, brightness(0.86) contrast(1.22) saturate(1.15));
    }

    #map.map-theme-fallback .leaflet-tile {
      filter: var(--map-tile-filter-fallback, brightness(1.12) contrast(1.1) saturate(1.06));
    }

    #map::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 300;
      background:
        radial-gradient(circle at 50% 52%, transparent 58%, rgba(8, 18, 34, 0.26) 100%),
        linear-gradient(90deg, rgba(9, 19, 36, 0.2), transparent 11%, transparent 89%, rgba(9, 19, 36, 0.2));
    }

    .map-status {
      position: absolute;
      right: 20px;
      top: 20px;
      padding: 10px 14px;
      background: rgba(6, 10, 18, 0.64);
      border: 1px solid rgba(84, 194, 255, 0.5);
      border-radius: 16px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.75rem;
      color: #b8d7eb;
      z-index: 700;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .map-status.fade {
      opacity: 0;
      transform: translateY(-4px);
    }

    #globe-view {
      z-index: 2;
      background: radial-gradient(circle at 50% 30%, rgba(34, 66, 118, 0.92), rgba(10, 18, 34, 0.92) 72%);
    }

    #globe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #sky-view {
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 50% 20%, rgba(10, 28, 60, 0.9), #04060c 70%);
      z-index: 3;
    }

    #sky {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .sky-overlay {
      position: absolute;
      left: 20px;
      top: 20px;
      padding: 10px 14px;
      background: rgba(6, 10, 18, 0.6);
      border: 1px solid rgba(100, 140, 200, 0.3);
      border-radius: 16px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.75rem;
      color: var(--muted);
      max-width: 240px;
    }

    .globe-overlay {
      position: absolute;
      left: 20px;
      top: 20px;
      padding: 10px 14px;
      background: rgba(6, 10, 18, 0.6);
      border: 1px solid rgba(100, 140, 200, 0.3);
      border-radius: 16px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.75rem;
      color: var(--muted);
      max-width: 240px;
      pointer-events: none;
    }

    .panel-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.6fr) minmax(0, 1fr);
      gap: 20px;
    }

    .pass-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .sky-event-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .sky-event-item {
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(12, 18, 32, 0.66);
      border: 1px solid rgba(120, 140, 180, 0.2);
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .sky-event-item.clickable {
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }

    .sky-event-item.clickable:hover {
      transform: translateY(-1px);
      border-color: rgba(42, 209, 255, 0.38);
      background: rgba(14, 22, 40, 0.9);
    }

    .sky-event-item.emphasis {
      border-color: rgba(255, 188, 105, 0.65);
      background: linear-gradient(135deg, rgba(255, 188, 105, 0.14), rgba(12, 18, 32, 0.9));
      box-shadow: 0 0 0 1px rgba(255, 188, 105, 0.2), 0 10px 24px rgba(34, 22, 10, 0.4);
    }

    .sky-event-item.selected {
      border-color: rgba(155, 92, 255, 0.72);
      background: linear-gradient(135deg, rgba(155, 92, 255, 0.2), rgba(14, 22, 40, 0.96));
      box-shadow:
        0 0 0 2px rgba(155, 92, 255, 0.6),
        0 0 0 5px rgba(155, 92, 255, 0.16),
        0 12px 26px rgba(18, 10, 38, 0.55);
      transform: translateY(-1px);
    }

    .forecast-note {
      margin: -4px 0 10px;
    }

    .pass-item {
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(12, 18, 32, 0.7);
      border: 1px solid rgba(120, 140, 180, 0.2);
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .pass-item.clickable {
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }

    .pass-item.clickable:hover {
      transform: translateY(-1px);
      border-color: rgba(42, 209, 255, 0.4);
      background: rgba(14, 22, 40, 0.9);
    }

    .pass-item.best {
      border-color: rgba(23, 241, 177, 0.7);
      background: linear-gradient(135deg, rgba(23, 241, 177, 0.12), rgba(12, 18, 32, 0.9));
      box-shadow: 0 0 0 1px rgba(23, 241, 177, 0.25), 0 12px 30px rgba(6, 20, 18, 0.35);
    }

    .pass-item.preview {
      border-color: rgba(155, 92, 255, 0.7);
      background: linear-gradient(135deg, rgba(155, 92, 255, 0.2), rgba(14, 22, 40, 0.95));
      box-shadow:
        0 0 0 2px rgba(155, 92, 255, 0.65),
        0 0 0 5px rgba(155, 92, 255, 0.18),
        0 14px 28px rgba(18, 10, 38, 0.55);
      transform: translateY(-1px);
    }

    .pass-item.preview .pass-title {
      color: #f0d8ff;
    }

    .pass-title {
      font-size: 0.9rem;
      margin: 0;
    }

    .pass-meta {
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .pass-meta.sky-highlight {
      color: #9fd6f3;
      margin-top: 3px;
    }

    .pass-meta.moon-phase {
      color: #d7dfff;
      margin-top: 3px;
    }

    .pass-meta.alignment-highlight {
      color: #f8d9a1;
      margin-top: 3px;
    }

    .badge-row {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }

    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.7rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      font-family: "IBM Plex Mono", monospace;
    }

    .badge.visible {
      background: rgba(23, 241, 177, 0.15);
      color: var(--success);
      border: 1px solid rgba(23, 241, 177, 0.4);
    }

    .badge.best {
      background: rgba(42, 209, 255, 0.2);
      color: var(--accent);
      border: 1px solid rgba(42, 209, 255, 0.5);
    }

    .badge.preview {
      background: rgba(155, 92, 255, 0.2);
      color: var(--accent-2);
      border: 1px solid rgba(155, 92, 255, 0.6);
    }

    .badge.alignment {
      background: rgba(255, 188, 105, 0.2);
      color: #ffd09c;
      border: 1px solid rgba(255, 188, 105, 0.55);
    }

    .badge.dark-sky {
      background: rgba(23, 241, 177, 0.18);
      color: #8effd0;
      border: 1px solid rgba(23, 241, 177, 0.5);
    }

    .badge.bright-moon {
      background: rgba(225, 232, 255, 0.2);
      color: #e8eeff;
      border: 1px solid rgba(196, 208, 255, 0.5);
    }

    .preview-banner {
      position: relative;
      margin: 0 0 0 auto;
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 14px;
      background: rgba(10, 14, 24, 0.75);
      border: 1px solid rgba(155, 92, 255, 0.45);
      border-radius: 16px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.75rem;
      color: var(--text);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 26px rgba(12, 10, 26, 0.5);
      max-width: 620px;
    }

    .preview-banner button {
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.7rem;
    }

    .preview-banner[hidden] {
      display: none !important;
    }

    .preview-banner span {
      flex: 1;
    }

    .badge.daylight {
      background: rgba(255, 180, 82, 0.15);
      color: var(--warning);
      border: 1px solid rgba(255, 180, 82, 0.4);
    }

    .badge.low {
      background: rgba(255, 107, 107, 0.15);
      color: var(--danger);
      border: 1px solid rgba(255, 107, 107, 0.4);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .settings-section {
      margin-top: 6px;
    }

    .control-group label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    .control-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    input[type="text"],
    input[type="number"] {
      background: rgba(6, 10, 18, 0.6);
      border: 1px solid rgba(120, 140, 180, 0.3);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-family: "IBM Plex Mono", monospace;
      font-size: 0.82rem;
      width: 100%;
      max-width: 140px;
    }

    input[type="range"] {
      width: 100%;
    }

    .footnote {
      font-size: 0.74rem;
      color: var(--muted);
      margin: 0;
    }

    .iss-marker .iss-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 1.5px solid rgba(3, 27, 42, 0.9);
      box-shadow: 0 0 0 1px rgba(87, 230, 255, 0.35), 0 0 12px rgba(42, 209, 255, 0.9);
      position: relative;
    }

    .iss-marker .iss-dot::after {
      content: "";
      position: absolute;
      inset: -10px;
      border-radius: 50%;
      border: 1px solid rgba(42, 209, 255, 0.4);
      animation: pulse 2.6s infinite ease-out;
    }

    .user-marker {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent-3);
      border: 1px solid rgba(3, 27, 42, 0.78);
      box-shadow: 0 0 0 1px rgba(23, 241, 177, 0.25), 0 0 12px rgba(23, 241, 177, 0.8);
    }

    @keyframes pulse {
      0% { transform: scale(0.6); opacity: 0.8; }
      100% { transform: scale(1.6); opacity: 0; }
    }

    @media (max-width: 900px) {
      .panel-grid {
        grid-template-columns: 1fr;
      }

      .viewer {
        min-height: 380px;
        padding-bottom: 0;
      }

      .sky-overlay,
      .globe-overlay {
        display: none;
      }

      .preview-banner {
        margin: 8px 0 0;
        max-width: 100%;
        width: 100%;
      }

      .view-toolbar {
        display: block;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title-row">
        <div>
          <h1>ISS Flyover Explorer</h1>
          <p class="subtitle">Track the International Space Station in real time, explore its orbital path, and get notified about night-time flyovers over your location.</p>
        </div>
        <div class="actions">
          <button id="locate" class="primary">Use My Location</button>
          <button id="notify">Enable Notifications</button>
          <button id="refresh">Recalculate Forecast</button>
        </div>
      </div>
      <div class="status-grid">
        <div class="card">
          <h3>ISS Position</h3>
          <div class="stat-value" id="iss-coords">Loadingâ€¦</div>
          <div class="stat-sub" id="iss-meta">Awaiting data</div>
        </div>
        <div class="card">
          <h3>Your Location</h3>
          <div class="stat-value" id="user-coords">Unknown</div>
          <div class="stat-sub" id="user-meta">Geolocation not set</div>
        </div>
        <div class="card">
          <h3>Next Visible Pass</h3>
          <div class="stat-value" id="next-pass">Calculatingâ€¦</div>
          <div class="stat-sub" id="next-pass-meta">Need location to predict</div>
        </div>
        <div class="card">
          <h3>Visibility Status</h3>
          <div class="stat-value" id="visibility">Night check pending</div>
          <div class="stat-sub" id="visibility-meta">Sun altitude unavailable</div>
        </div>
        <div class="card">
          <h3>Moon Phase</h3>
          <div class="stat-value" id="moon-phase">Calculatingâ€¦</div>
          <div class="stat-sub" id="moon-phase-meta">Need location to evaluate sky darkness</div>
        </div>
      </div>
    </header>

    <div class="view-toolbar">
      <div class="view-toggle" role="tablist">
        <button id="btn-map">Map View</button>
        <button class="active" id="btn-globe">Globe View</button>
        <button id="btn-sky">User View</button>
      </div>
      <div class="preview-banner" id="preview-banner" hidden>
        <span id="preview-text">Previewing pass</span>
        <button id="preview-exit">Return to Live</button>
      </div>
    </div>

    <section class="viewer">
      <div id="map" class="view-panel" aria-label="ISS ground track map"></div>
      <div id="globe-view" class="view-panel active" aria-label="ISS globe view">
        <div id="globe"></div>
        <div class="globe-overlay">Drag to rotate, scroll to zoom. Track paths are computed from live ISS TLE data.</div>
      </div>
      <div id="sky-view" class="view-panel" aria-label="ISS sky view">
        <canvas id="sky"></canvas>
        <div class="sky-overlay">Drag to rotate the sky, scroll to zoom. The arc shows the ISS pass and planet markers show naked-eye targets.</div>
      </div>
    </section>

    <section class="panel-grid">
      <div class="card">
        <h3>Flyover Forecast (Next 7 Days)</h3>
        <div class="stat-sub forecast-note">Sky highlights show naked-eye planets plus moon phase context. ISS Best remains based on ISS visibility.</div>
        <div class="pass-list" id="pass-list">
          <div class="pass-item">
            <div>
              <p class="pass-title">Waiting for locationâ€¦</p>
              <div class="pass-meta">Enable geolocation to calculate passes</div>
            </div>
            <span class="badge daylight">Standby</span>
          </div>
        </div>
      </div>
      <div class="card">
        <h3>Naked-Eye Sky Highlights (Next 7 Days)</h3>
        <div class="sky-event-list" id="sky-events-list">
          <div class="sky-event-item">
            <div>
              <p class="pass-title">Waiting for locationâ€¦</p>
              <div class="pass-meta">Enable geolocation to calculate sky highlights</div>
            </div>
            <span class="badge daylight">Standby</span>
          </div>
        </div>
      </div>
    </section>

    <section class="settings-section">
      <div class="card controls">
        <div class="control-group">
          <label>Manual Coordinates</label>
          <div class="control-row">
            <input id="lat" type="number" step="0.0001" placeholder="Lat" />
            <input id="lon" type="number" step="0.0001" placeholder="Lon" />
            <button id="apply-coords">Apply</button>
          </div>
        </div>
        <div class="control-group">
          <label>Track Path Window (Hours)</label>
          <input id="track-hours" type="range" min="2" max="12" value="6" />
          <div class="stat-sub" id="track-hours-label">6 hours of orbit path</div>
        </div>
        <div class="control-group">
          <label>Update Interval</label>
          <div class="stat-sub">ISS position refreshes every 6 seconds. Forecast recalculates on refresh.</div>
        </div>
        <p class="footnote">Notifications use the browser Notification API and require this tab to stay open. Full push requires a service worker and a server-side push subscription.</p>
      </div>
    </section>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const state = {
      user: null,
      iss: null,
      issSamples: { prev: null, next: null },
      tle: null,
      tleUpdated: 0,
      map: null,
      mapTileLayer: null,
      mapTheme: "primary",
      mapFitZoom: 2,
      mapFallbackNotified: false,
      markers: {},
      trackOutline: null,
      trackLine: null,
      trackGlow: null,
      trackData: [],
      trail: [],
      passes: [],
      goodPasses: [],
      passSkyHighlights: {},
      alignmentEvents: [],
      skyEvents: [],
      planetCache: new Map(),
      nextVisible: null,
      notificationTimer: null,
      notificationsEnabled: false,
      anim: { rafId: null, lastStatus: 0 },
      preview: { active: false, mode: "live", pass: null, skyEvent: null },
      globe: {
        ready: false,
        scene: null,
        camera: null,
        renderer: null,
        controls: null,
        earth: null,
        issMesh: null,
        userMesh: null,
        trackLine: null,
        trackGlow: null
      },
      sky: {
        rotation: 0,
        zoom: 1,
        dragging: false,
        dragStart: null,
        stars: []
      }
    };

    const ISS_NOW_URL = "https://api.wheretheiss.at/v1/satellites/25544";
    const ISS_POS_URL = "https://api.wheretheiss.at/v1/satellites/25544/positions?timestamps=";
    const ISS_TLE_URL = "https://api.wheretheiss.at/v1/satellites/25544/tles";
    const STORAGE_KEY = "iss-flyover-location";
    const FORECAST_DAYS = 7;
    const GLOBE_VISUALS = {
      texturePrimary: "https://unpkg.com/three-globe/example/img/earth-day.jpg",
      textureFallback: "https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg",
      toneMappingExposure: 1.18,
      ambientIntensity: 0.95,
      keyIntensity: 1.1,
      keyPosition: [4.8, 2.6, 5.2],
      fillIntensity: 0.38,
      fillPosition: [-4.2, -1.4, -4.8],
      emissive: 0x0f1523,
      shininess: 10,
      atmosphereOpacity: 0.05
    };
    const MAP_VISUALS = {
      tilePrimary: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png",
      tileFallback: "https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png",
      tileFilterPrimary: "brightness(0.86) contrast(1.22) saturate(1.15)",
      tileFilterFallback: "brightness(1.12) contrast(1.10) saturate(1.06)",
      mapBackground: "#1a2940",
      trackOutlineColor: "#031b2a",
      trackGlowColor: "#22d5ff",
      trackDashColor: "#57e6ff"
    };
    const PLANET_VISUALS = {
      planets: [
        { body: "Mercury", color: "#d0bea5" },
        { body: "Venus", color: "#ffd56a" },
        { body: "Mars", color: "#ff9166" },
        { body: "Jupiter", color: "#f1e8c9" },
        { body: "Saturn", color: "#e7c589" }
      ],
      moon: { body: "Moon", color: "#ccd8ff" },
      minElevationDeg: 5,
      maxSunAltitudeDeg: -6,
      brightMagnitude: 1.5,
      darkSkyIlluminationPctMax: 30,
      brightMoonIlluminationPctMin: 70,
      alignmentSeparationDeg: 4.0,
      alignmentWindowSeconds: 3600,
      alignmentStepMinutes: 30,
      moonPhaseBands: [
        { max: 0.0625, name: "New Moon", icon: "ðŸŒ‘" },
        { max: 0.1875, name: "Waxing Crescent", icon: "ðŸŒ’" },
        { max: 0.3125, name: "First Quarter", icon: "ðŸŒ“" },
        { max: 0.4375, name: "Waxing Gibbous", icon: "ðŸŒ”" },
        { max: 0.5625, name: "Full Moon", icon: "ðŸŒ•" },
        { max: 0.6875, name: "Waning Gibbous", icon: "ðŸŒ–" },
        { max: 0.8125, name: "Last Quarter", icon: "ðŸŒ—" },
        { max: 0.9375, name: "Waning Crescent", icon: "ðŸŒ˜" },
        { max: 1.01, name: "New Moon", icon: "ðŸŒ‘" }
      ]
    };

    const mapEl = document.getElementById("map");
    const globeViewEl = document.getElementById("globe-view");
    const globeEl = document.getElementById("globe");
    const skyViewEl = document.getElementById("sky-view");
    const skyCanvas = document.getElementById("sky");
    const passList = document.getElementById("pass-list");
    const skyEventsList = document.getElementById("sky-events-list");
    const previewBanner = document.getElementById("preview-banner");
    const previewText = document.getElementById("preview-text");

    const formatCoord = (val) => `${val.toFixed(3)}Â°`;
    const formatTime = (date) => date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    const formatDateTime = (date) => date.toLocaleString([], { weekday: "short", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" });

    function getMoonPhaseInfo(date) {
      const illumination = SunCalc.getMoonIllumination(date);
      const phaseValue = ((illumination?.phase ?? 0) + 1) % 1;
      const illuminationPct = Math.round((illumination?.fraction ?? 0) * 100);
      const band = PLANET_VISUALS.moonPhaseBands.find((entry) => phaseValue <= entry.max) || PLANET_VISUALS.moonPhaseBands[0];
      return {
        phaseValue,
        illuminationPct,
        name: band.name,
        icon: band.icon
      };
    }

    function getMoonlightQuality({ illuminationPct, moonVisible }) {
      let quality = "balanced";
      if (!moonVisible || illuminationPct <= PLANET_VISUALS.darkSkyIlluminationPctMax) {
        quality = "dark";
      } else if (moonVisible && illuminationPct >= PLANET_VISUALS.brightMoonIlluminationPctMin) {
        quality = "bright";
      }

      // Informational score only; this does not influence ISS best-pass selection.
      let darkSkyScore = 100 - illuminationPct;
      if (!moonVisible) darkSkyScore = Math.min(100, darkSkyScore + 25);
      darkSkyScore = Math.min(100, Math.max(0, darkSkyScore));
      return { quality, darkSkyScore };
    }

    function moonlightQualityLabel(quality) {
      if (quality === "dark") return "Dark sky";
      if (quality === "bright") return "Bright moon";
      return "Balanced";
    }

    function moonlightBadgeValue(quality) {
      if (quality === "dark") return "dark";
      if (quality === "bright") return "bright";
      return "";
    }

    function formatMoonPhaseLine(moonPhase, prefix) {
      if (!moonPhase) return "";
      return `${prefix}: ${moonPhase.icon} ${moonPhase.name} (${moonPhase.illuminationPct}%)`;
    }

    function wrapLongitude(lon) {
      return ((lon + 540) % 360) - 180;
    }

    function computeNoWrapFitZoom(width) {
      const safeWidth = Math.max(320, width || window.innerWidth || 1024);
      const zoom = Math.log2(safeWidth / 256);
      return Math.min(3.0, Math.max(1.5, zoom));
    }

    function syncMapNoWrapZoomConstraints(force = false) {
      if (!state.map) return;
      const width = mapEl.clientWidth || state.map.getSize().x || window.innerWidth;
      const fitZoom = computeNoWrapFitZoom(width);
      if (!force && Math.abs(fitZoom - state.mapFitZoom) < 0.01) return;

      state.mapFitZoom = fitZoom;
      state.map.setMinZoom(fitZoom);
      if (state.map.getZoom() < fitZoom) {
        state.map.setZoom(fitZoom, { animate: false });
      }
    }

    function setMapTheme(theme) {
      const nextTheme = theme === "fallback" ? "fallback" : "primary";
      state.mapTheme = nextTheme;
      mapEl.classList.remove("map-theme-primary", "map-theme-fallback");
      mapEl.classList.add(nextTheme === "fallback" ? "map-theme-fallback" : "map-theme-primary");
    }

    function passKey(pass) {
      return `${pass.start}-${pass.end}`;
    }

    function azimuthToCompass(azimuth) {
      const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      const normalized = ((azimuth % 360) + 360) % 360;
      const index = Math.round(normalized / 22.5) % directions.length;
      return directions[index];
    }

    function averageAzimuth(azA, azB) {
      const a = toRadians(azA);
      const b = toRadians(azB);
      const x = Math.cos(a) + Math.cos(b);
      const y = Math.sin(a) + Math.sin(b);
      return (toDegrees(Math.atan2(y, x)) + 360) % 360;
    }

    function angularSeparation(raDegA, decDegA, raDegB, decDegB) {
      const raA = toRadians(raDegA);
      const decA = toRadians(decDegA);
      const raB = toRadians(raDegB);
      const decB = toRadians(decDegB);
      const cosSep = Math.sin(decA) * Math.sin(decB) + Math.cos(decA) * Math.cos(decB) * Math.cos(raA - raB);
      return toDegrees(Math.acos(Math.max(-1, Math.min(1, cosSep))));
    }

    function getPlanetObservation(body, date, observer, sunAltitude) {
      if (!window.Astronomy || !observer) return null;
      try {
        const equatorial = window.Astronomy.Equator(body, date, observer, true, true);
        const horizontal = window.Astronomy.Horizon(date, observer, equatorial.ra, equatorial.dec, "normal");
        const illumination = window.Astronomy.Illumination(body, date);
        const elevation = horizontal.altitude;
        const azimuth = (horizontal.azimuth + 360) % 360;
        const magnitude = Number.isFinite(illumination?.mag) ? illumination.mag : null;
        return {
          body,
          azimuth,
          elevation,
          magnitude,
          bright: magnitude !== null && magnitude <= PLANET_VISUALS.brightMagnitude,
          visible: sunAltitude < PLANET_VISUALS.maxSunAltitudeDeg && elevation >= PLANET_VISUALS.minElevationDeg,
          raDeg: equatorial.ra * 15,
          decDeg: equatorial.dec
        };
      } catch (error) {
        console.warn(`Planet observation failed for ${body}.`, error);
        return null;
      }
    }

    function getSkyContextAt(date, lat, lon) {
      const minute = Math.floor(date.getTime() / 60000);
      const cacheKey = `${lat.toFixed(3)}|${lon.toFixed(3)}|${minute}`;
      const cached = state.planetCache.get(cacheKey);
      if (cached) return cached;

      const sunAltitude = SunCalc.getPosition(date, lat, lon).altitude * 180 / Math.PI;
      const darkEnough = sunAltitude < PLANET_VISUALS.maxSunAltitudeDeg;
      const moonPhase = getMoonPhaseInfo(date);
      const moonAltitudeFallback = SunCalc.getMoonPosition(date, lat, lon).altitude * 180 / Math.PI;

      if (!window.Astronomy || !window.Astronomy.Observer) {
        const moonVisibleFallback = darkEnough && moonAltitudeFallback >= PLANET_VISUALS.minElevationDeg;
        const moonlight = getMoonlightQuality({
          illuminationPct: moonPhase.illuminationPct,
          moonVisible: moonVisibleFallback
        });
        const fallbackContext = {
          darkEnough,
          sunAltitude,
          visiblePlanets: [],
          moon: null,
          observations: [],
          moonPhase,
          moonlightQuality: moonlight.quality,
          darkSkyScore: moonlight.darkSkyScore
        };
        state.planetCache.set(cacheKey, fallbackContext);
        return fallbackContext;
      }

      const observer = new window.Astronomy.Observer(lat, lon, 0);
      const observations = [];
      PLANET_VISUALS.planets.forEach((planet) => {
        const observation = getPlanetObservation(planet.body, date, observer, sunAltitude);
        if (!observation) return;
        observations.push({ ...observation, color: planet.color });
      });

      const visiblePlanets = observations
        .filter((observation) => observation.visible)
        .sort((a, b) => {
          const magA = Number.isFinite(a.magnitude) ? a.magnitude : 99;
          const magB = Number.isFinite(b.magnitude) ? b.magnitude : 99;
          if (magA !== magB) return magA - magB;
          return b.elevation - a.elevation;
        });

      const moonObs = getPlanetObservation(PLANET_VISUALS.moon.body, date, observer, sunAltitude);
      const moonVisible = moonObs && moonObs.elevation >= PLANET_VISUALS.minElevationDeg && darkEnough
        ? { ...moonObs, color: PLANET_VISUALS.moon.color }
        : null;
      const moonlight = getMoonlightQuality({
        illuminationPct: moonPhase.illuminationPct,
        moonVisible: Boolean(moonVisible)
      });

      const context = {
        darkEnough,
        sunAltitude,
        visiblePlanets,
        moon: moonVisible,
        observations,
        moonPhase,
        moonlightQuality: moonlight.quality,
        darkSkyScore: moonlight.darkSkyScore
      };

      state.planetCache.set(cacheKey, context);
      return context;
    }

    function computeAlignmentEvents(startTimestamp, endTimestamp, lat, lon) {
      if (!window.Astronomy || !window.Astronomy.Observer) return [];
      const stepSeconds = PLANET_VISUALS.alignmentStepMinutes * 60;
      const active = new Map();
      const events = [];

      for (let ts = startTimestamp; ts <= endTimestamp; ts += stepSeconds) {
        const context = getSkyContextAt(new Date(ts * 1000), lat, lon);
        const planets = context.visiblePlanets;
        const seenPairs = new Set();

        for (let i = 0; i < planets.length; i++) {
          for (let j = i + 1; j < planets.length; j++) {
            const a = planets[i];
            const b = planets[j];
            const separation = angularSeparation(a.raDeg, a.decDeg, b.raDeg, b.decDeg);
            if (separation > PLANET_VISUALS.alignmentSeparationDeg) continue;

            const bodies = [a.body, b.body].sort((left, right) => left.localeCompare(right));
            const pairId = bodies.join("|");
            seenPairs.add(pairId);
            const azimuth = averageAzimuth(a.azimuth, b.azimuth);
            const elevation = (a.elevation + b.elevation) / 2;

            if (!active.has(pairId)) {
              active.set(pairId, {
                pairId,
                bodies,
                start: ts,
                end: ts,
                peakTs: ts,
                minSeparation: separation,
                azimuth,
                elevation
              });
            } else {
              const event = active.get(pairId);
              event.end = ts;
              if (separation < event.minSeparation) {
                event.minSeparation = separation;
                event.peakTs = ts;
                event.azimuth = azimuth;
                event.elevation = elevation;
              }
            }
          }
        }

        for (const [pairId, event] of active.entries()) {
          if (seenPairs.has(pairId)) continue;
          events.push({
            ...event,
            label: `${event.bodies[0]} + ${event.bodies[1]}`,
            direction: azimuthToCompass(event.azimuth)
          });
          active.delete(pairId);
        }
      }

      for (const event of active.values()) {
        events.push({
          ...event,
          label: `${event.bodies[0]} + ${event.bodies[1]}`,
          direction: azimuthToCompass(event.azimuth)
        });
      }

      return events.sort((a, b) => a.peakTs - b.peakTs);
    }

    function findNearbyAlignment(peakTimestamp, alignmentEvents) {
      let nearest = null;
      alignmentEvents.forEach((event) => {
        const delta = Math.abs(event.peakTs - peakTimestamp);
        if (delta > PLANET_VISUALS.alignmentWindowSeconds) return;
        if (!nearest || delta < nearest.delta) {
          nearest = { event, delta };
        }
      });
      return nearest ? nearest.event : null;
    }

    function formatSkyTarget(target) {
      const direction = azimuthToCompass(target.azimuth);
      return `${target.body} ${Math.round(target.elevation)}Â° ${direction}`;
    }

    function buildSkyEvents(lat, lon, alignmentEvents) {
      const now = Math.floor(Date.now() / 1000);
      const end = now + FORECAST_DAYS * 24 * 3600;
      const groupingStepSeconds = PLANET_VISUALS.alignmentStepMinutes * 60;
      const dailyBest = new Map();

      for (let ts = now; ts <= end; ts += groupingStepSeconds) {
        const context = getSkyContextAt(new Date(ts * 1000), lat, lon);
        if (!context.darkEnough || context.visiblePlanets.length < 2) continue;
        const topTargets = context.visiblePlanets.slice(0, 4);
        const score = topTargets.length * 100 + topTargets.reduce((sum, target) => sum + target.elevation, 0);
        const dayKey = new Date(ts * 1000).toLocaleDateString("en-CA");
        const existing = dailyBest.get(dayKey);
        if (!existing || score > existing.score) {
          dailyBest.set(dayKey, { timestamp: ts, score, topTargets });
        }
      }

      const groupingEventsRaw = Array.from(dailyBest.values()).map((entry) => {
        const topTargets = entry.topTargets;
        const names = topTargets.map((target) => target.body);
        const summary = topTargets.map((target) => formatSkyTarget(target)).join(" â€¢ ");
        const context = getSkyContextAt(new Date(entry.timestamp * 1000), lat, lon);
        return {
          id: `group-${entry.timestamp}-${names.join("-")}`,
          type: "group",
          focusTs: entry.timestamp,
          start: entry.timestamp - 45 * 60,
          end: entry.timestamp + 45 * 60,
          emphasis: topTargets.length >= 3,
          bodies: names,
          title: `Planet grouping: ${names.join(", ")}`,
          meta: `Best around ${formatDateTime(new Date(entry.timestamp * 1000))}`,
          details: summary,
          moonPhaseSummary: formatMoonPhaseLine(context.moonPhase, "Moon"),
          moonlightSummary: `Moonlight: ${moonlightQualityLabel(context.moonlightQuality)}`,
          moonlightBadge: moonlightBadgeValue(context.moonlightQuality),
          darkSkyScore: context.darkSkyScore,
          score: entry.score
        };
      });

      const groupingEvents = groupingEventsRaw
        .sort((left, right) => left.start - right.start)
        .map((event) => {
          const { score, ...clean } = event;
          return clean;
        });

      const alignmentHighlights = alignmentEvents
        .filter((event) => event.end > now)
        .map((event) => {
          const context = getSkyContextAt(new Date(event.peakTs * 1000), lat, lon);
          return {
            id: `align-${event.pairId}-${event.peakTs}`,
            type: "alignment",
            focusTs: event.peakTs,
            start: event.start,
            end: event.end,
            emphasis: event.minSeparation <= 2.5,
            bodies: event.bodies,
            title: `${event.label} alignment`,
            meta: `Closest ${event.minSeparation.toFixed(1)}Â° at ${formatDateTime(new Date(event.peakTs * 1000))}`,
            details: `Direction ${event.direction} â€¢ Altitude ${Math.round(event.elevation)}Â°`,
            moonPhaseSummary: formatMoonPhaseLine(context.moonPhase, "Moon"),
            moonlightSummary: `Moonlight: ${moonlightQualityLabel(context.moonlightQuality)}`,
            moonlightBadge: moonlightBadgeValue(context.moonlightQuality),
            darkSkyScore: context.darkSkyScore
          };
        });

      return [...alignmentHighlights, ...groupingEvents]
        .sort((left, right) => left.start - right.start)
        .slice(0, 14);
    }

    function renderSkyEventsList() {
      if (!skyEventsList) return;
      skyEventsList.innerHTML = "";

      if (!state.user) {
        skyEventsList.innerHTML = `
          <div class="sky-event-item">
            <div>
              <p class="pass-title">Waiting for locationâ€¦</p>
              <div class="pass-meta">Enable geolocation to calculate sky highlights</div>
            </div>
            <span class="badge daylight">Standby</span>
          </div>
        `;
        return;
      }

      if (!window.Astronomy || !window.Astronomy.Observer) {
        skyEventsList.innerHTML = `
          <div class="sky-event-item">
            <div>
              <p class="pass-title">Sky engine unavailable</p>
              <div class="pass-meta">Could not load planetary calculations</div>
            </div>
            <span class="badge low">Unavailable</span>
          </div>
        `;
        return;
      }

      if (!state.skyEvents.length) {
        skyEventsList.innerHTML = `
          <div class="sky-event-item">
            <div>
              <p class="pass-title">No standout naked-eye events in the next ${FORECAST_DAYS} days</p>
              <div class="pass-meta">Try refreshing or checking a different location</div>
            </div>
            <span class="badge daylight">Quiet</span>
          </div>
        `;
        return;
      }

      const selectedEventId = state.preview.active && state.preview.mode === "event" ? state.preview.skyEvent?.id : null;
      state.skyEvents.forEach((event) => {
        const item = document.createElement("div");
        const isSelected = selectedEventId === event.id;
        item.className = `sky-event-item clickable${event.emphasis ? " emphasis" : ""}${isSelected ? " selected" : ""}`;
        const badges = [];
        if (isSelected) badges.push('<span class="badge preview">Preview</span>');
        if (event.type === "alignment") badges.push('<span class="badge alignment">Alignment</span>');
        if (event.emphasis) badges.push('<span class="badge best">Best Night</span>');
        if (event.moonlightBadge === "dark") badges.push('<span class="badge dark-sky">Dark Sky</span>');
        if (event.moonlightBadge === "bright") badges.push('<span class="badge bright-moon">Bright Moon</span>');
        const badgeColumn = badges.length ? `<div class="badge-row">${badges.join("")}</div>` : "";
        const moonContextLine = [event.moonPhaseSummary, event.moonlightSummary].filter(Boolean).join(" â€¢ ");
        item.innerHTML = `
          <div>
            <p class="pass-title">${event.title}</p>
            <div class="pass-meta">${event.meta}</div>
            <div class="pass-meta sky-highlight">${event.details}</div>
            ${moonContextLine ? `<div class="pass-meta moon-phase">${moonContextLine}</div>` : ""}
          </div>
          ${badgeColumn}
        `;
        item.addEventListener("click", () => setSkyEventPreview(event));
        skyEventsList.appendChild(item);
      });
    }

    function enrichPassesWithSkyContext(passes) {
      state.passSkyHighlights = {};
      if (!state.user || !window.Astronomy || !window.Astronomy.Observer) {
        state.alignmentEvents = [];
        state.skyEvents = [];
        return passes;
      }

      const now = Math.floor(Date.now() / 1000);
      const end = now + FORECAST_DAYS * 24 * 3600;
      state.alignmentEvents = computeAlignmentEvents(now, end, state.user.lat, state.user.lon);
      state.skyEvents = buildSkyEvents(state.user.lat, state.user.lon, state.alignmentEvents);

      return passes.map((pass) => {
        if (!pass.visible) {
          const quiet = {
            skySummary: "",
            moonSummary: "",
            moonPhaseSummary: "",
            moonlightSummary: "",
            moonlightBadge: "",
            darkSkyScore: 0,
            alignmentSummary: "",
            topTargets: [],
            alignmentEvent: null
          };
          state.passSkyHighlights[passKey(pass)] = quiet;
          return { ...pass, ...quiet };
        }

        const peakTimestamp = pass.peakPoint?.timestamp || Math.round((pass.start + pass.end) / 2);
        const sampleTimes = [pass.start, peakTimestamp, pass.end];
        const sampleContexts = sampleTimes.map((timestamp) => ({
          timestamp,
          context: getSkyContextAt(new Date(timestamp * 1000), state.user.lat, state.user.lon)
        }));
        const bestTargets = new Map();
        let bestMoon = null;

        sampleContexts.forEach(({ context }) => {
          context.visiblePlanets.forEach((target) => {
            const existing = bestTargets.get(target.body);
            if (!existing || target.elevation > existing.elevation) {
              bestTargets.set(target.body, target);
            }
          });
          if (context.moon && (!bestMoon || context.moon.elevation > bestMoon.elevation)) {
            bestMoon = context.moon;
          }
        });

        const topTargets = Array.from(bestTargets.values())
          .sort((a, b) => {
            const magA = Number.isFinite(a.magnitude) ? a.magnitude : 99;
            const magB = Number.isFinite(b.magnitude) ? b.magnitude : 99;
            if (magA !== magB) return magA - magB;
            return b.elevation - a.elevation;
          })
          .slice(0, 3);

        const peakContextEntry = sampleContexts.reduce((closest, entry) => {
          if (!closest) return entry;
          return Math.abs(entry.timestamp - peakTimestamp) < Math.abs(closest.timestamp - peakTimestamp) ? entry : closest;
        }, null);
        const peakContext = peakContextEntry ? peakContextEntry.context : null;
        const alignmentEvent = findNearbyAlignment(peakTimestamp, state.alignmentEvents);
        const skySummary = topTargets.length ? `Sky: ${topTargets.map(formatSkyTarget).join(", ")}` : "";
        const moonSummary = bestMoon ? `Moon: ${Math.round(bestMoon.elevation)}Â° ${azimuthToCompass(bestMoon.azimuth)}` : "";
        const moonPhaseSummary = peakContext?.moonPhase ? formatMoonPhaseLine(peakContext.moonPhase, "Moon phase") : "";
        const moonlightQuality = peakContext?.moonlightQuality || "balanced";
        const moonlightSummary = `Moonlight: ${moonlightQualityLabel(moonlightQuality)}`;
        const moonlightBadge = moonlightBadgeValue(moonlightQuality);
        const darkSkyScore = peakContext?.darkSkyScore ?? 0;
        const alignmentSummary = alignmentEvent
          ? `${alignmentEvent.label} ${alignmentEvent.minSeparation.toFixed(1)}Â° apart`
          : "";

        const highlight = {
          skySummary,
          moonSummary,
          moonPhaseSummary,
          moonlightSummary,
          moonlightBadge,
          darkSkyScore,
          alignmentSummary,
          topTargets,
          alignmentEvent
        };
        state.passSkyHighlights[passKey(pass)] = highlight;
        return { ...pass, ...highlight };
      });
    }

    function registerGestureBlocker(element, isActive) {
      if (!element) return;
      let active = false;

      const onTouchStart = () => {
        active = isActive();
      };

      const onTouchMove = (event) => {
        if (!active || !isActive()) return;
        if (event.cancelable) {
          event.preventDefault();
        }
      };

      const onTouchEnd = () => {
        active = false;
      };

      element.addEventListener("touchstart", onTouchStart, { passive: true });
      element.addEventListener("touchmove", onTouchMove, { passive: false });
      element.addEventListener("touchend", onTouchEnd, { passive: true });
      element.addEventListener("touchcancel", onTouchEnd, { passive: true });
    }

    function saveUserLocation(lat, lon, source) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          lat,
          lon,
          source,
          savedAt: Date.now()
        }));
      } catch (error) {
        console.warn("Unable to persist location", error);
      }
    }

    function loadStoredLocation() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const data = JSON.parse(raw);
        if (!Number.isFinite(data.lat) || !Number.isFinite(data.lon)) return false;
        state.user = {
          lat: data.lat,
          lon: data.lon,
          source: data.source ? `${data.source} (saved)` : "Saved location"
        };
        updateUserMarker();
        setStatus();
        return true;
      } catch (error) {
        console.warn("Stored location unavailable", error);
        return false;
      }
    }

    function interpolateLongitude(lonA, lonB, t) {
      let delta = lonB - lonA;
      if (Math.abs(delta) > 180) {
        delta -= Math.sign(delta) * 360;
      }
      return wrapLongitude(lonA + delta * t);
    }

    function interpolateSample(prev, next, nowMs) {
      if (!prev && !next) return null;
      if (!prev) return next;
      if (!next) return prev;
      const span = Math.max(1, next.localTime - prev.localTime);
      const t = Math.min(1, Math.max(0, (nowMs - prev.localTime) / span));
      const altitudeA = prev.altitude ?? 0;
      const altitudeB = next.altitude ?? altitudeA;
      const velocityA = prev.velocity ?? 0;
      const velocityB = next.velocity ?? velocityA;
      return {
        ...next,
        latitude: prev.latitude + (next.latitude - prev.latitude) * t,
        longitude: interpolateLongitude(prev.longitude, next.longitude, t),
        altitude: altitudeA + (altitudeB - altitudeA) * t,
        velocity: velocityA + (velocityB - velocityA) * t
      };
    }

    function buildTrackSegments(points) {
      if (!points.length) return [];
      const segments = [];
      let segment = [];
      points.forEach((point) => {
        if (!segment.length) {
          segment.push(point);
          return;
        }
        const prev = segment[segment.length - 1];
        const delta = Math.abs(point.longitude - prev.longitude);
        if (delta > 180) {
          segments.push(segment);
          segment = [point];
        } else {
          segment.push(point);
        }
      });
      if (segment.length) segments.push(segment);
      return segments.map((seg) => seg.map((p) => [p.latitude, p.longitude]));
    }

    function setStatus() {
      const issCoords = document.getElementById("iss-coords");
      const issMeta = document.getElementById("iss-meta");
      const userCoords = document.getElementById("user-coords");
      const userMeta = document.getElementById("user-meta");
      const nextPass = document.getElementById("next-pass");
      const nextPassMeta = document.getElementById("next-pass-meta");
      const visibility = document.getElementById("visibility");
      const visibilityMeta = document.getElementById("visibility-meta");
      const moonPhase = document.getElementById("moon-phase");
      const moonPhaseMeta = document.getElementById("moon-phase-meta");

      if (state.iss) {
        issCoords.textContent = `${formatCoord(state.iss.latitude)}, ${formatCoord(state.iss.longitude)}`;
        issMeta.textContent = `Altitude ${state.iss.altitude.toFixed(1)} km â€¢ Velocity ${state.iss.velocity.toFixed(0)} km/h`;
      } else {
        issCoords.textContent = "Loadingâ€¦";
        issMeta.textContent = "Awaiting data";
      }

      if (state.user) {
        userCoords.textContent = `${formatCoord(state.user.lat)}, ${formatCoord(state.user.lon)}`;
        userMeta.textContent = state.user.source || "Custom location";
      } else {
        userCoords.textContent = "Unknown";
        userMeta.textContent = "Geolocation not set";
      }

      if (state.nextVisible) {
        nextPass.textContent = formatDateTime(new Date(state.nextVisible.start * 1000));
        nextPassMeta.textContent = `Max elevation ${state.nextVisible.maxEl.toFixed(0)}Â° â€¢ Visible ${state.nextVisible.duration} min`;
      } else {
        nextPass.textContent = "No visible pass found";
        nextPassMeta.textContent = state.user ? `No good passes in the next ${FORECAST_DAYS} days` : "Need location to predict";
      }

      if (state.user) {
        const nowContext = getSkyContextAt(new Date(), state.user.lat, state.user.lon);
        const sunAlt = nowContext.sunAltitude;
        const label = sunAlt < -6 ? "Night" : sunAlt < 0 ? "Civil Twilight" : "Daylight";
        visibility.textContent = label;
        visibilityMeta.textContent = `Sun altitude ${sunAlt.toFixed(1)}Â°`;
        if (nowContext.moonPhase) {
          moonPhase.textContent = `${nowContext.moonPhase.icon} ${nowContext.moonPhase.name} â€¢ ${nowContext.moonPhase.illuminationPct}%`;
          if (sunAlt < PLANET_VISUALS.maxSunAltitudeDeg) {
            moonPhaseMeta.textContent = `Moonlight ${moonlightQualityLabel(nowContext.moonlightQuality)} â€¢ Dark-sky score ${Math.round(nowContext.darkSkyScore)}/100`;
          } else {
            moonPhaseMeta.textContent = `Daylight now â€¢ Dark-sky score ${Math.round(nowContext.darkSkyScore)}/100`;
          }
        } else {
          moonPhase.textContent = "Unavailable";
          moonPhaseMeta.textContent = "Moon phase data unavailable";
        }
      } else {
        visibility.textContent = "Night check pending";
        visibilityMeta.textContent = "Sun altitude unavailable";
        moonPhase.textContent = "Calculatingâ€¦";
        moonPhaseMeta.textContent = "Need location to evaluate sky darkness";
      }
    }

    function showMapMessage(message) {
      if (state.mapFallbackNotified) return;
      state.mapFallbackNotified = true;

      const existing = mapEl.querySelector(".map-status");
      if (existing) existing.remove();

      const note = document.createElement("div");
      note.className = "map-status";
      note.textContent = message;
      mapEl.appendChild(note);

      window.setTimeout(() => {
        note.classList.add("fade");
        window.setTimeout(() => note.remove(), 360);
      }, 4200);
    }

    function initMap() {
      const bounds = L.latLngBounds([[-85, -180], [85, 180]]);
      const initialZoom = computeNoWrapFitZoom(mapEl.clientWidth || window.innerWidth);
      state.mapFitZoom = initialZoom;

      mapEl.style.setProperty("--map-bg", MAP_VISUALS.mapBackground);
      mapEl.style.setProperty("--map-tile-filter-primary", MAP_VISUALS.tileFilterPrimary);
      mapEl.style.setProperty("--map-tile-filter-fallback", MAP_VISUALS.tileFilterFallback);
      setMapTheme("primary");

      state.map = L.map(mapEl, {
        zoomControl: true,
        worldCopyJump: false,
        maxBounds: bounds,
        maxBoundsViscosity: 1.0,
        preferCanvas: false,
        minZoom: initialZoom,
        maxZoom: 8
      }).setView([0, 0], initialZoom);

      const createTileLayer = (url) => L.tileLayer(url, {
        attribution: "&copy; OpenStreetMap contributors &copy; CARTO",
        subdomains: "abcd",
        maxZoom: 8,
        noWrap: true,
        bounds
      });

      state.mapTileLayer = createTileLayer(MAP_VISUALS.tilePrimary).addTo(state.map);

      let tileErrors = 0;
      const tileErrorLimit = 3;
      const tileErrorWindowMs = 12000;
      const tileLoadStart = Date.now();
      const activateFallback = () => {
        if (state.mapTheme === "fallback") return;
        if (state.mapTileLayer) {
          state.map.removeLayer(state.mapTileLayer);
        }
        state.mapTileLayer = createTileLayer(MAP_VISUALS.tileFallback).addTo(state.map);
        setMapTheme("fallback");
        showMapMessage("Map style fallback active.");
      };

      state.mapTileLayer.on("tileerror", () => {
        if (state.mapTheme === "fallback") return;
        if (Date.now() - tileLoadStart > tileErrorWindowMs) return;
        tileErrors += 1;
        if (tileErrors >= tileErrorLimit) {
          activateFallback();
        }
      });

      const issIcon = L.divIcon({
        className: "iss-marker",
        html: '<div class="iss-dot"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });

      state.markers.iss = L.marker([0, 0], { icon: issIcon }).addTo(state.map);
      state.trackOutline = L.polyline([], {
        color: MAP_VISUALS.trackOutlineColor,
        weight: 7,
        opacity: 0.55,
        lineCap: "round"
      }).addTo(state.map);
      state.trackGlow = L.polyline([], {
        color: MAP_VISUALS.trackGlowColor,
        weight: 5,
        opacity: 0.30,
        lineCap: "round"
      }).addTo(state.map);
      state.trackLine = L.polyline([], {
        color: MAP_VISUALS.trackDashColor,
        weight: 2.6,
        opacity: 0.95,
        dashArray: "7 9",
        lineCap: "round"
      }).addTo(state.map);

      syncMapNoWrapZoomConstraints(true);
    }

    function initMapResizing() {
      if (!state.map) return;
      let queued = false;
      const queueInvalidate = () => {
        if (queued) return;
        queued = true;
        requestAnimationFrame(() => {
          queued = false;
          state.map.invalidateSize({ animate: false });
          syncMapNoWrapZoomConstraints();
        });
      };

      window.addEventListener("resize", queueInvalidate);
      window.addEventListener("scroll", queueInvalidate, { passive: true });

      if (window.ResizeObserver) {
        const observer = new ResizeObserver(queueInvalidate);
        observer.observe(document.querySelector(".viewer"));
      }

      if (window.IntersectionObserver) {
        const observer = new IntersectionObserver((entries) => {
          if (entries.some((entry) => entry.isIntersecting)) {
            queueInvalidate();
          }
        }, { threshold: 0.1 });
        observer.observe(mapEl);
      }
    }

    function updateISSMarker() {
      if (state.iss && state.map && state.markers.iss) {
        state.markers.iss.setLatLng([state.iss.latitude, state.iss.longitude]);
      }
      updateGlobeMarkers();
    }

    function updateUserMarker() {
      if (!state.user || !state.map) return;
      if (!state.markers.user) {
        const userIcon = L.divIcon({
          className: "user-marker",
          html: "",
          iconSize: [10, 10],
          iconAnchor: [5, 5]
        });
        state.markers.user = L.marker([state.user.lat, state.user.lon], { icon: userIcon }).addTo(state.map);
      } else {
        state.markers.user.setLatLng([state.user.lat, state.user.lon]);
      }
      updateGlobeMarkers();
    }

    function updateTrackLine() {
      if (!state.map || !state.trackOutline || !state.trackLine || !state.trackGlow) return;
      const source = state.trackData.length ? state.trackData : state.trail;
      const segments = buildTrackSegments(source);
      if (segments.length) {
        state.trackOutline.setLatLngs(segments);
        state.trackGlow.setLatLngs(segments);
        state.trackLine.setLatLngs(segments);
      } else {
        state.trackOutline.setLatLngs([]);
        state.trackGlow.setLatLngs([]);
        state.trackLine.setLatLngs([]);
      }
      updateGlobeTrack();
    }

    function latLonToVector3(lat, lon, radius = 1) {
      const phi = toRadians(90 - lat);
      const theta = toRadians(lon + 180);
      return new THREE.Vector3(
        -radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.cos(phi),
        radius * Math.sin(phi) * Math.sin(theta)
      );
    }

    function renderGlobe() {
      if (!state.globe.ready) return;
      if (state.globe.controls) {
        state.globe.controls.update();
      }
      state.globe.renderer.render(state.globe.scene, state.globe.camera);
    }

    function createFallbackControls(camera, domElement) {
      const stateControls = {
        dragging: false,
        startX: 0,
        startY: 0,
        theta: 0,
        phi: 0,
        radius: camera.position.length()
      };

      const updateCamera = () => {
        const phi = Math.max(0.1, Math.min(Math.PI - 0.1, stateControls.phi));
        camera.position.set(
          stateControls.radius * Math.sin(phi) * Math.sin(stateControls.theta),
          stateControls.radius * Math.cos(phi),
          stateControls.radius * Math.sin(phi) * Math.cos(stateControls.theta)
        );
        camera.lookAt(0, 0, 0);
        renderGlobe();
      };

      const initial = camera.position.clone();
      stateControls.radius = initial.length();
      stateControls.phi = Math.acos(initial.y / stateControls.radius);
      stateControls.theta = Math.atan2(initial.x, initial.z);
      updateCamera();

      const onPointerDown = (event) => {
        stateControls.dragging = true;
        stateControls.startX = event.clientX;
        stateControls.startY = event.clientY;
        domElement.setPointerCapture(event.pointerId);
      };

      const onPointerMove = (event) => {
        if (!stateControls.dragging) return;
        const dx = event.clientX - stateControls.startX;
        const dy = event.clientY - stateControls.startY;
        stateControls.startX = event.clientX;
        stateControls.startY = event.clientY;
        stateControls.theta -= dx * 0.005;
        stateControls.phi += dy * 0.005;
        updateCamera();
      };

      const onPointerUp = (event) => {
        stateControls.dragging = false;
        domElement.releasePointerCapture(event.pointerId);
      };

      const onWheel = (event) => {
        event.preventDefault();
        const delta = Math.sign(event.deltaY);
        stateControls.radius = Math.min(4.2, Math.max(1.6, stateControls.radius + delta * 0.15));
        updateCamera();
      };

      domElement.addEventListener("pointerdown", onPointerDown);
      domElement.addEventListener("pointermove", onPointerMove);
      domElement.addEventListener("pointerup", onPointerUp);
      domElement.addEventListener("wheel", onWheel, { passive: false });
      domElement.style.cursor = "grab";

      return {
        update: () => {},
        dispose: () => {
          domElement.removeEventListener("pointerdown", onPointerDown);
          domElement.removeEventListener("pointermove", onPointerMove);
          domElement.removeEventListener("pointerup", onPointerUp);
          domElement.removeEventListener("wheel", onWheel);
        }
      };
    }

    function resizeGlobe() {
      if (!state.globe.ready) return;
      const rect = globeViewEl.getBoundingClientRect();
      if (!rect.width || !rect.height) return;
      state.globe.renderer.setPixelRatio(window.devicePixelRatio || 1);
      state.globe.renderer.setSize(rect.width, rect.height, false);
      state.globe.camera.aspect = rect.width / rect.height;
      state.globe.camera.updateProjectionMatrix();
      renderGlobe();
    }

    function showGlobeMessage(message) {
      const existing = globeViewEl.querySelector(".globe-status");
      if (existing) existing.remove();
      const note = document.createElement("div");
      note.className = "globe-status";
      note.textContent = message;
      Object.assign(note.style, {
        position: "absolute",
        right: "20px",
        top: "20px",
        padding: "10px 14px",
        background: "rgba(6, 10, 18, 0.6)",
        border: "1px solid rgba(100, 140, 200, 0.3)",
        borderRadius: "16px",
        fontFamily: "\"IBM Plex Mono\", monospace",
        fontSize: "0.75rem",
        color: "var(--muted)"
      });
      globeViewEl.appendChild(note);
    }

    function initGlobe() {
      if (!window.THREE || !window.THREE.WebGLRenderer) {
        showGlobeMessage("WebGL unavailable. Globe view disabled.");
        return;
      }
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      if ("outputColorSpace" in renderer && THREE.SRGBColorSpace) {
        renderer.outputColorSpace = THREE.SRGBColorSpace;
      } else if ("outputEncoding" in renderer && THREE.sRGBEncoding) {
        renderer.outputEncoding = THREE.sRGBEncoding;
      }
      if (THREE.ACESFilmicToneMapping) {
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = GLOBE_VISUALS.toneMappingExposure;
      }
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(globeEl.clientWidth, globeEl.clientHeight);
      globeEl.innerHTML = "";
      globeEl.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, globeEl.clientWidth / globeEl.clientHeight, 0.1, 100);
      camera.position.set(0, 0, 3);

      const hasControls = !!window.THREE.OrbitControls;
      const controls = hasControls
        ? new THREE.OrbitControls(camera, renderer.domElement)
        : createFallbackControls(camera, renderer.domElement);
      if (hasControls) {
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.enablePan = false;
        controls.minDistance = 1.7;
        controls.maxDistance = 4;
      }

      const ambient = new THREE.AmbientLight(0xffffff, GLOBE_VISUALS.ambientIntensity);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, GLOBE_VISUALS.keyIntensity);
      keyLight.position.set(...GLOBE_VISUALS.keyPosition);
      scene.add(keyLight);

      // Fill light prevents night-side crushing when rotating.
      const fillLight = new THREE.DirectionalLight(0xa9c3ff, GLOBE_VISUALS.fillIntensity);
      fillLight.position.set(...GLOBE_VISUALS.fillPosition);
      scene.add(fillLight);

      const globeGroup = new THREE.Group();
      scene.add(globeGroup);

      const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
      const textureLoader = new THREE.TextureLoader();
      const earthMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: new THREE.Color(GLOBE_VISUALS.emissive),
        shininess: GLOBE_VISUALS.shininess
      });
      const earth = new THREE.Mesh(earthGeometry, earthMaterial);
      globeGroup.add(earth);

      const setTextureColorSpace = (texture) => {
        if ("colorSpace" in texture && THREE.SRGBColorSpace) {
          texture.colorSpace = THREE.SRGBColorSpace;
        } else if ("encoding" in texture && THREE.sRGBEncoding) {
          texture.encoding = THREE.sRGBEncoding;
        }
      };

      const loadEarthTexture = (url, onSuccess, onError) => {
        textureLoader.load(
          url,
          (texture) => {
            setTextureColorSpace(texture);
            onSuccess(texture);
          },
          undefined,
          onError
        );
      };

      loadEarthTexture(
        GLOBE_VISUALS.texturePrimary,
        (texture) => {
          earthMaterial.map = texture;
          earthMaterial.needsUpdate = true;
          renderGlobe();
        },
        () => {
          loadEarthTexture(
            GLOBE_VISUALS.textureFallback,
            (texture) => {
              earthMaterial.map = texture;
              earthMaterial.needsUpdate = true;
              renderGlobe();
            },
            () => {
              earthMaterial.color = new THREE.Color(0x3b6d98);
              earthMaterial.needsUpdate = true;
              showGlobeMessage("Globe texture failed to load. Showing simplified surface.");
              renderGlobe();
            }
          );
        }
      );

      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(1.02, 64, 64),
        new THREE.MeshBasicMaterial({ color: 0x2ad1ff, transparent: true, opacity: GLOBE_VISUALS.atmosphereOpacity })
      );
      globeGroup.add(atmosphere);

      const issMesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.02, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x2ad1ff })
      );
      scene.add(issMesh);

      const userMesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.018, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x17f1b1 })
      );
      scene.add(userMesh);

      state.globe = {
        ready: true,
        scene,
        camera,
        renderer,
        controls,
        earth,
        issMesh,
        userMesh,
        trackLine: null,
        trackGlow: null
      };

      if (hasControls) {
        controls.addEventListener("change", renderGlobe);
      }
      window.addEventListener("resize", resizeGlobe);
      resizeGlobe();
      updateGlobeMarkers();
      updateGlobeTrack();
      renderGlobe();
      requestAnimationFrame(resizeGlobe);
    }

    function updateGlobeMarkers() {
      if (!state.globe.ready) return;
      if (state.iss) {
        const radius = 1 + (state.iss.altitude || 420) / 6378.137;
        state.globe.issMesh.position.copy(latLonToVector3(state.iss.latitude, state.iss.longitude, radius));
        state.globe.issMesh.visible = true;
      } else {
        state.globe.issMesh.visible = false;
      }
      if (state.user) {
        state.globe.userMesh.position.copy(latLonToVector3(state.user.lat, state.user.lon, 1.015));
        state.globe.userMesh.visible = true;
      } else {
        state.globe.userMesh.visible = false;
      }
    }

    function updateGlobeTrack() {
      if (!state.globe.ready) return;
      const source = state.trackData.length ? state.trackData : state.trail;
      const points = source.map((p) => latLonToVector3(p.latitude, p.longitude, 1.03));
      if (state.globe.trackLine) {
        state.globe.scene.remove(state.globe.trackLine);
        state.globe.trackLine.geometry.dispose();
        state.globe.trackLine.material.dispose();
        state.globe.trackLine = null;
      }
      if (state.globe.trackGlow) {
        state.globe.scene.remove(state.globe.trackGlow);
        state.globe.trackGlow.geometry.dispose();
        state.globe.trackGlow.material.dispose();
        state.globe.trackGlow = null;
      }
      if (points.length < 2) return;

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const glowMaterial = new THREE.LineBasicMaterial({
        color: 0x2ad1ff,
        transparent: true,
        opacity: 0.22,
        depthTest: true,
        depthWrite: false
      });
      const glow = new THREE.Line(geometry, glowMaterial);

      const dashedMaterial = new THREE.LineDashedMaterial({
        color: 0x2ad1ff,
        dashSize: 0.05,
        gapSize: 0.03,
        transparent: true,
        opacity: 0.95,
        depthTest: true,
        depthWrite: false
      });
      const dashed = new THREE.Line(geometry, dashedMaterial);
      dashed.computeLineDistances();
      glow.frustumCulled = false;
      dashed.frustumCulled = false;
      glow.renderOrder = 2;
      dashed.renderOrder = 3;

      state.globe.scene.add(glow);
      state.globe.scene.add(dashed);
      state.globe.trackGlow = glow;
      state.globe.trackLine = dashed;
      renderGlobe();
    }

    async function fetchISSNow() {
      const response = await fetch(ISS_NOW_URL);
      if (!response.ok) {
        throw new Error("ISS API failed");
      }
      const data = await response.json();
      const sample = { ...data, localTime: Date.now() };
      state.issSamples.prev = state.issSamples.next || sample;
      state.issSamples.next = sample;
      state.iss = sample;
      state.trail.push({ latitude: sample.latitude, longitude: sample.longitude });
      if (state.trail.length > 240) {
        state.trail.splice(0, state.trail.length - 240);
      }
      updateISSMarker();
      updateTrackLine();
      setStatus();
    }

    function buildTimestamps(hours, stepSeconds, maxPoints = 360) {
      const safeHours = Number.isFinite(hours) && hours > 0 ? hours : 6;
      let safeStep = Number.isFinite(stepSeconds) && stepSeconds > 0 ? stepSeconds : 60;
      const totalSeconds = safeHours * 3600;
      const minStep = Math.max(30, Math.ceil(totalSeconds / maxPoints));
      if (safeStep < minStep) safeStep = minStep;

      const now = Math.floor(Date.now() / 1000);
      const end = now + totalSeconds;
      const stamps = [];
      for (let t = now; t <= end; t += safeStep) {
        stamps.push(t);
      }
      return stamps;
    }

    async function ensureTLE() {
      const now = Date.now();
      if (state.tle && now - state.tleUpdated < 6 * 3600 * 1000) {
        return state.tle;
      }
      const response = await fetch(ISS_TLE_URL);
      if (!response.ok) {
        throw new Error("TLE API failed");
      }
      const data = await response.json();
      if (!window.satellite || !data.line1 || !data.line2) {
        throw new Error("TLE parsing unavailable");
      }
      const satrec = window.satellite.twoline2satrec(data.line1, data.line2);
      state.tle = { ...data, satrec };
      state.tleUpdated = now;
      return state.tle;
    }

    function buildTrackFromTLE(satrec, timestamps) {
      const track = [];
      timestamps.forEach((ts) => {
        const date = new Date(ts * 1000);
        const pv = window.satellite.propagate(satrec, date);
        if (!pv.position) return;
        const gmst = window.satellite.gstime(date);
        const geodetic = window.satellite.eciToGeodetic(pv.position, gmst);
        const latitude = window.satellite.degreesLat(geodetic.latitude);
        const longitude = window.satellite.degreesLong(geodetic.longitude);
        const altitude = geodetic.height;
        let velocity;
        if (pv.velocity) {
          const v = pv.velocity;
          velocity = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z) * 3600;
        }
        track.push({ timestamp: ts, latitude, longitude, altitude, velocity });
      });
      return track;
    }

    async function fetchISSTrack(hours = 6, stepSeconds = 60) {
      const timestamps = buildTimestamps(hours, stepSeconds, 360);
      if (!timestamps.length) {
        state.trackData = [];
        updateTrackLine();
        return [];
      }

      if (window.satellite) {
        try {
          const tle = await ensureTLE();
          const track = buildTrackFromTLE(tle.satrec, timestamps);
          state.trackData = track;
          updateTrackLine();
          return track;
        } catch (error) {
          console.warn("TLE track failed, falling back to positions API.", error);
        }
      }

      const limitedTimestamps = timestamps.slice(0, 10);
      const response = await fetch(`${ISS_POS_URL}${limitedTimestamps.join(",")}`);
      if (!response.ok) {
        throw new Error("ISS track API failed");
      }
      const data = await response.json();
      state.trackData = data;
      updateTrackLine();
      return data;
    }

    async function fetchISSForecast(days = FORECAST_DAYS, stepSeconds = 120) {
      if (!window.satellite) return [];
      try {
        const tle = await ensureTLE();
        const timestamps = buildTimestamps(days * 24, stepSeconds, 6000);
        return buildTrackFromTLE(tle.satrec, timestamps);
      } catch (error) {
        console.warn("Forecast generation failed.", error);
        return [];
      }
    }

    async function refinePasses(passes, stepSeconds = 10) {
      if (!window.satellite || !state.user || !passes.length) return passes;
      try {
        const tle = await ensureTLE();
        const refined = [];
        for (const pass of passes) {
          const stamps = [];
          for (let t = pass.start; t <= pass.end; t += stepSeconds) {
            stamps.push(t);
          }
          const track = buildTrackFromTLE(tle.satrec, stamps);
          const observer = ecefFromLatLon(state.user.lat, state.user.lon, 0);
          const points = track.map((p) => {
            const sat = ecefFromLatLon(p.latitude, p.longitude, p.altitude || 0);
            const look = topocentricAzEl(observer, sat);
            return { ...p, ...look };
          });

          const above = points.filter((pt) => pt.elevation > 0);
          if (!above.length) {
            refined.push(pass);
            continue;
          }
          const first = above[0];
          const last = above[above.length - 1];
          const peak = above.reduce((a, b) => (b.elevation > a.elevation ? b : a), above[0]);
          const sunAlt = SunCalc.getPosition(new Date(peak.timestamp * 1000), state.user.lat, state.user.lon).altitude * 180 / Math.PI;
          const night = sunAlt < -6;
          const durationMin = Math.max(1, Math.round((last.timestamp - first.timestamp) / 60));

          refined.push({
            ...pass,
            start: first.timestamp,
            end: last.timestamp,
            duration: durationMin,
            maxEl: peak.elevation,
            peakPoint: peak,
            night,
            visible: night && peak.elevation > 20 && durationMin >= 2,
            points
          });
        }
        return refined;
      } catch (error) {
        console.warn("Pass refinement failed.", error);
        return passes;
      }
    }

    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    function toDegrees(rad) {
      return rad * 180 / Math.PI;
    }

    function ecefFromLatLon(lat, lon, altKm) {
      const a = 6378.137;
      const e2 = 0.00669437999014;
      const latRad = toRadians(lat);
      const lonRad = toRadians(lon);
      const sinLat = Math.sin(latRad);
      const cosLat = Math.cos(latRad);
      const sinLon = Math.sin(lonRad);
      const cosLon = Math.cos(lonRad);
      const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
      const x = (N + altKm) * cosLat * cosLon;
      const y = (N + altKm) * cosLat * sinLon;
      const z = (N * (1 - e2) + altKm) * sinLat;
      return { x, y, z, sinLat, cosLat, sinLon, cosLon };
    }

    function topocentricAzEl(observer, satellite) {
      const rx = satellite.x - observer.x;
      const ry = satellite.y - observer.y;
      const rz = satellite.z - observer.z;

      const east = -observer.sinLon * rx + observer.cosLon * ry;
      const north = -observer.sinLat * observer.cosLon * rx - observer.sinLat * observer.sinLon * ry + observer.cosLat * rz;
      const up = observer.cosLat * observer.cosLon * rx + observer.cosLat * observer.sinLon * ry + observer.sinLat * rz;

      const az = Math.atan2(east, north);
      const el = Math.atan2(up, Math.sqrt(east * east + north * north));
      return { azimuth: (toDegrees(az) + 360) % 360, elevation: toDegrees(el) };
    }

    function computePasses(samples) {
      if (!state.user) return [];
      const observer = ecefFromLatLon(state.user.lat, state.user.lon, 0);
      const enriched = samples.map((p) => {
        const sat = ecefFromLatLon(p.latitude, p.longitude, p.altitude || 0);
        const look = topocentricAzEl(observer, sat);
        return { ...p, ...look };
      });

      const passes = [];
      let current = null;

      for (const point of enriched) {
        if (point.elevation > 0) {
          if (!current) {
            current = { start: point.timestamp, end: point.timestamp, points: [point], maxEl: point.elevation };
          } else {
            current.end = point.timestamp;
            current.points.push(point);
            current.maxEl = Math.max(current.maxEl, point.elevation);
          }
        } else if (current) {
          passes.push(current);
          current = null;
        }
      }
      if (current) passes.push(current);

      return passes.map((pass) => {
        const peak = pass.points.reduce((a, b) => (b.elevation > a.elevation ? b : a), pass.points[0]);
        const sunAlt = SunCalc.getPosition(new Date(peak.timestamp * 1000), state.user.lat, state.user.lon).altitude * 180 / Math.PI;
        const night = sunAlt < -6;
        const durationMin = Math.max(1, Math.round((pass.end - pass.start) / 60));
        return {
          start: pass.start,
          end: pass.end,
          duration: durationMin,
          maxEl: peak.elevation,
          peakPoint: peak,
          night,
          visible: night && peak.elevation > 20 && durationMin >= 2,
          points: pass.points
        };
      });
    }

    function renderPassList() {
      passList.innerHTML = "";
      if (!state.user) {
        passList.innerHTML = `
          <div class="pass-item">
            <div>
              <p class="pass-title">Waiting for locationâ€¦</p>
              <div class="pass-meta">Enable geolocation to calculate visible passes</div>
            </div>
            <span class="badge daylight">Standby</span>
          </div>
        `;
        return;
      }
      if (!state.goodPasses.length) {
        passList.innerHTML = `
          <div class="pass-item">
            <div>
              <p class="pass-title">No visible passes in the next ${FORECAST_DAYS} days</p>
              <div class="pass-meta">Check again later or adjust your location</div>
            </div>
            <span class="badge low">None</span>
          </div>
        `;
        return;
      }

      const bestPass = getBestPass(state.goodPasses);
      const previewKey = state.preview.active && state.preview.mode === "pass" && state.preview.pass
        ? passKey(state.preview.pass)
        : null;
      state.goodPasses.slice(0, 14).forEach((pass) => {
        const isBest = bestPass && pass.start === bestPass.start && pass.end === bestPass.end;
        const isPreview = previewKey && passKey(pass) === previewKey;
        const item = document.createElement("div");
        item.className = `pass-item clickable${isBest ? " best" : ""}${isPreview ? " preview" : ""}`;
        const badges = [];
        if (isPreview) badges.push('<span class="badge preview">Preview</span>');
        else if (isBest) badges.push('<span class="badge best">Best</span>');
        if (pass.alignmentEvent) {
          badges.push('<span class="badge alignment">Alignment</span>');
        }
        if (pass.moonlightBadge === "dark") badges.push('<span class="badge dark-sky">Dark Sky</span>');
        if (pass.moonlightBadge === "bright") badges.push('<span class="badge bright-moon">Bright Moon</span>');
        const badgeColumn = badges.length ? `<div class="badge-row">${badges.join("")}</div>` : "";
        const highlights = [
          pass.skySummary ? `<div class="pass-meta sky-highlight">${pass.skySummary}</div>` : "",
          pass.moonSummary ? `<div class="pass-meta sky-highlight">${pass.moonSummary}</div>` : "",
          pass.moonPhaseSummary ? `<div class="pass-meta moon-phase">${pass.moonPhaseSummary}</div>` : "",
          pass.moonlightSummary ? `<div class="pass-meta moon-phase">${pass.moonlightSummary}</div>` : "",
          pass.alignmentSummary ? `<div class="pass-meta alignment-highlight">Alignment: ${pass.alignmentSummary}</div>` : ""
        ].join("");
        item.innerHTML = `
          <div>
            <p class="pass-title">${formatDateTime(new Date(pass.start * 1000))}</p>
            <div class="pass-meta">Visible ${pass.duration} min â€¢ Max elevation ${pass.maxEl.toFixed(0)}Â°</div>
            ${highlights}
          </div>
          ${badgeColumn}
        `;
        item.addEventListener("click", () => setPreviewPass(pass));
        passList.appendChild(item);
      });
    }

    function updateNextVisible() {
      const now = Date.now() / 1000;
      const upcoming = state.goodPasses.filter((p) => p.end > now + 60);
      state.nextVisible = upcoming[0] || null;
    }

    function getBestPass(passes) {
      if (!passes.length) return null;
      return passes.reduce((best, pass) => {
        const skyScore = (entry) => (entry.topTargets?.length || 0) + (entry.alignmentEvent ? 1 : 0) + (entry.moonSummary ? 0.5 : 0);
        if (pass.maxEl > best.maxEl) return pass;
        if (pass.maxEl === best.maxEl && pass.duration > best.duration) return pass;
        if (pass.maxEl === best.maxEl && pass.duration === best.duration && skyScore(pass) > skyScore(best)) return pass;
        if (pass.maxEl === best.maxEl && pass.duration === best.duration && skyScore(pass) === skyScore(best) && pass.start < best.start) return pass;
        return best;
      }, passes[0]);
    }

    function setPreviewPass(pass) {
      if (!pass) return;
      state.preview.active = true;
      state.preview.mode = "pass";
      state.preview.pass = pass;
      state.preview.skyEvent = null;
      renderPassList();
      renderSkyEventsList();
      previewText.textContent = `Previewing pass ${formatDateTime(new Date(pass.start * 1000))}`;
      previewBanner.hidden = false;
      setActiveView("sky");
      updateSkyCanvas();
    }

    function setSkyEventPreview(event) {
      if (!event) return;
      state.preview.active = true;
      state.preview.mode = "event";
      state.preview.pass = null;
      state.preview.skyEvent = event;
      renderPassList();
      renderSkyEventsList();
      const previewTs = event.focusTs || event.start;
      previewText.textContent = `Previewing sky ${formatDateTime(new Date(previewTs * 1000))}`;
      previewBanner.hidden = false;
      setActiveView("sky");
      updateSkyCanvas();
    }

    function clearPreview() {
      state.preview.active = false;
      state.preview.mode = "live";
      state.preview.pass = null;
      state.preview.skyEvent = null;
      renderPassList();
      renderSkyEventsList();
      previewBanner.hidden = true;
      updateSkyCanvas();
    }

    function scheduleNotification() {
      if (!state.notificationsEnabled) return;
      if (state.notificationTimer) clearTimeout(state.notificationTimer);
      if (!state.nextVisible) return;

      const notifyTime = (state.nextVisible.start * 1000) - 10 * 60 * 1000;
      const delay = notifyTime - Date.now();
      if (delay <= 0) return;

      state.notificationTimer = setTimeout(() => {
        if (Notification.permission === "granted") {
          new Notification("ISS flyover tonight", {
            body: `Visible pass at ${formatTime(new Date(state.nextVisible.start * 1000))} â€¢ Max ${state.nextVisible.maxEl.toFixed(0)}Â°`,
            tag: "iss-flyover"
          });
        }
      }, delay);
    }

    function updateSkyCanvas() {
      const ctx = skyCanvas.getContext("2d");
      const width = skyCanvas.clientWidth;
      const height = skyCanvas.clientHeight;
      ctx.clearRect(0, 0, width, height);

      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) * 0.42 * state.sky.zoom;

      const gradient = ctx.createRadialGradient(cx, cy, radius * 0.1, cx, cy, radius);
      gradient.addColorStop(0, "rgba(16, 32, 64, 0.95)");
      gradient.addColorStop(1, "rgba(2, 6, 12, 0.95)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(state.sky.rotation);

      const toXY = (azimuth, elevation) => {
        const clampedElevation = Math.max(0, Math.min(90, elevation));
        const r = radius * (1 - clampedElevation / 90);
        const angle = toRadians(azimuth);
        return {
          x: Math.sin(angle) * r,
          y: -Math.cos(angle) * r
        };
      };

      for (const star of state.sky.stars) {
        const point = toXY(star.az, star.el);
        ctx.fillStyle = star.bright;
        ctx.beginPath();
        ctx.arc(point.x, point.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = "rgba(120, 150, 200, 0.3)";
      ctx.lineWidth = 1;
      [30, 60].forEach((alt) => {
        const r = radius * (1 - alt / 90);
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
      });

      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(42, 209, 255, 0.6)";
      ctx.stroke();

      const directions = [
        { label: "N", az: 0 },
        { label: "E", az: 90 },
        { label: "S", az: 180 },
        { label: "W", az: 270 }
      ];
      ctx.fillStyle = "rgba(230, 237, 246, 0.7)";
      ctx.font = "12px IBM Plex Mono";
      directions.forEach((d) => {
        const r = radius + 12;
        const angle = toRadians(d.az);
        ctx.fillText(d.label, Math.sin(angle) * r - 4, -Math.cos(angle) * r + 4);
      });

      const previewMode = state.preview.active ? state.preview.mode : "live";
      const skyPass = previewMode === "pass" ? state.preview.pass : previewMode === "event" ? null : state.nextVisible;
      const previewEvent = previewMode === "event" ? state.preview.skyEvent : null;
      const contextDate = previewMode === "pass" && state.preview.pass
        ? new Date((state.preview.pass.peakPoint?.timestamp || state.preview.pass.start) * 1000)
        : previewMode === "event" && previewEvent
          ? new Date((previewEvent.focusTs || previewEvent.start) * 1000)
          : new Date();

      if (state.user) {
        const skyContext = getSkyContextAt(contextDate, state.user.lat, state.user.lon);
        if (skyContext.darkEnough && (skyContext.visiblePlanets.length || skyContext.moon)) {
          ctx.font = "11px IBM Plex Mono";
          const labelBoxes = [];
          const hasOverlap = (candidate) => labelBoxes.some((box) => (
            candidate.x < box.x + box.width &&
            candidate.x + candidate.width > box.x &&
            candidate.y < box.y + box.height &&
            candidate.y + candidate.height > box.y
          ));

          const placeLabel = (text, anchor) => {
            const width = ctx.measureText(text).width + 6;
            const height = 14;
            const candidates = [
              { x: anchor.x + 8, y: anchor.y - 14, width, height },
              { x: anchor.x + 8, y: anchor.y + 4, width, height },
              { x: anchor.x - width - 8, y: anchor.y - 14, width, height },
              { x: anchor.x - width - 8, y: anchor.y + 4, width, height },
              { x: anchor.x - width / 2, y: anchor.y - 20, width, height },
              { x: anchor.x - width / 2, y: anchor.y + 10, width, height }
            ];

            const choice = candidates.find((candidate) => !hasOverlap(candidate)) || candidates[0];
            labelBoxes.push(choice);
            return choice;
          };

          const highlightedBodies = previewEvent?.bodies ? new Set(previewEvent.bodies) : null;
          const drawTarget = (target, size) => {
            const point = toXY(target.azimuth, target.elevation);
            const isHighlighted = highlightedBodies ? highlightedBodies.has(target.body) : false;
            const dotSize = isHighlighted ? size + 1.25 : size;
            ctx.fillStyle = target.color;
            ctx.strokeStyle = "rgba(7, 14, 28, 0.92)";
            ctx.lineWidth = 1.4;
            ctx.beginPath();
            ctx.arc(point.x, point.y, dotSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            if (target.bright || target.body === "Moon" || isHighlighted) {
              ctx.strokeStyle = `${target.color}88`;
              ctx.lineWidth = isHighlighted ? 1.4 : 1;
              ctx.beginPath();
              ctx.arc(point.x, point.y, dotSize + (isHighlighted ? 4.2 : 2.8), 0, Math.PI * 2);
              ctx.stroke();
            }

            const label = `${target.body} ${Math.round(target.elevation)}Â°`;
            const box = placeLabel(label, point);
            ctx.fillStyle = "rgba(4, 10, 20, 0.72)";
            ctx.strokeStyle = "rgba(102, 132, 173, 0.35)";
            ctx.lineWidth = 1;
            ctx.fillRect(box.x - 2, box.y - 1, box.width + 4, box.height + 2);
            ctx.strokeRect(box.x - 2, box.y - 1, box.width + 4, box.height + 2);
            ctx.fillStyle = target.color;
            ctx.fillText(label, box.x + 3, box.y + 10.5);
          };

          skyContext.visiblePlanets.forEach((target) => drawTarget(target, 3.1));
          if (skyContext.moon) {
            drawTarget(skyContext.moon, 3.6);
          }
        }
      }

      if (skyPass && skyPass.points) {
        ctx.strokeStyle = "rgba(23, 241, 177, 0.9)";
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        skyPass.points.forEach((pt, idx) => {
          const { x, y } = toXY(pt.azimuth, pt.elevation);
          if (idx === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();

        if (skyPass.points.length >= 2) {
          const last = skyPass.points[skyPass.points.length - 1];
          const end = toXY(last.azimuth, last.elevation);
          let start = null;
          for (let i = skyPass.points.length - 2; i >= 0; i--) {
            const candidate = toXY(skyPass.points[i].azimuth, skyPass.points[i].elevation);
            const dx = end.x - candidate.x;
            const dy = end.y - candidate.y;
            if (dx * dx + dy * dy > 1) {
              start = candidate;
              break;
            }
          }

          if (start) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const ux = dx / len;
            const uy = dy / len;
            const arrowSize = 14;
            const leftX = end.x - ux * arrowSize - uy * (arrowSize * 0.6);
            const leftY = end.y - uy * arrowSize + ux * (arrowSize * 0.6);
            const rightX = end.x - ux * arrowSize + uy * (arrowSize * 0.6);
            const rightY = end.y - uy * arrowSize - ux * (arrowSize * 0.6);

            ctx.fillStyle = "rgba(23, 241, 177, 0.95)";
            ctx.strokeStyle = "rgba(10, 14, 24, 0.9)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(leftX, leftY);
            ctx.lineTo(rightX, rightY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
        }
      }

      if (state.preview.active && state.preview.pass?.peakPoint) {
        const pt = state.preview.pass.peakPoint;
        const { x, y } = toXY(pt.azimuth, pt.elevation);
        ctx.fillStyle = "rgba(155, 92, 255, 0.95)";
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      } else if (state.iss && state.user) {
        const observer = ecefFromLatLon(state.user.lat, state.user.lon, 0);
        const sat = ecefFromLatLon(state.iss.latitude, state.iss.longitude, state.iss.altitude || 0);
        const look = topocentricAzEl(observer, sat);
        if (look.elevation > 0) {
          const { x, y } = toXY(look.azimuth, look.elevation);
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    function resizeSky() {
      const rect = skyViewEl.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      skyCanvas.width = rect.width * ratio;
      skyCanvas.height = rect.height * ratio;
      const ctx = skyCanvas.getContext("2d");
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(ratio, ratio);
      updateSkyCanvas();
    }

    function initSky() {
      state.sky.stars = Array.from({ length: 140 }).map(() => ({
        az: Math.random() * 360,
        el: Math.random() * 90,
        size: Math.random() * 1.5 + 0.4,
        bright: `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.1})`
      }));

      const handlePointer = (event) => {
        if (!state.sky.dragging) return;
        const dx = event.clientX - state.sky.dragStart.x;
        state.sky.rotation = state.sky.dragStart.rotation + dx * 0.01;
        updateSkyCanvas();
      };

      skyCanvas.addEventListener("pointerdown", (event) => {
        state.sky.dragging = true;
        state.sky.dragStart = { x: event.clientX, rotation: state.sky.rotation };
        skyCanvas.setPointerCapture(event.pointerId);
      });

      skyCanvas.addEventListener("pointermove", handlePointer);

      skyCanvas.addEventListener("pointerup", (event) => {
        state.sky.dragging = false;
        skyCanvas.releasePointerCapture(event.pointerId);
      });

      skyCanvas.addEventListener("wheel", (event) => {
        event.preventDefault();
        const delta = Math.sign(event.deltaY) * 0.05;
        state.sky.zoom = Math.min(1.4, Math.max(0.8, state.sky.zoom - delta));
        updateSkyCanvas();
      }, { passive: false });

      window.addEventListener("resize", resizeSky);
      resizeSky();
    }

    async function refreshAll() {
      try {
        state.planetCache.clear();
        state.passSkyHighlights = {};
        state.alignmentEvents = [];
        await fetchISSNow();
        const hoursRaw = Number(document.getElementById("track-hours")?.value ?? 6);
        const hours = Number.isFinite(hoursRaw) ? hoursRaw : 6;
        await fetchISSTrack(hours, 60);
        const forecast = await fetchISSForecast(FORECAST_DAYS, 120);
        state.passes = computePasses(forecast);
        state.passes = await refinePasses(state.passes, 10);
        state.passes = enrichPassesWithSkyContext(state.passes);
        state.goodPasses = state.passes.filter((pass) => pass.visible);
        if (state.preview.active) {
          if (state.preview.mode === "pass") {
            const match = state.goodPasses.find((pass) => pass.start === state.preview.pass?.start && pass.end === state.preview.pass?.end);
            if (match) {
              state.preview.pass = match;
            } else {
              clearPreview();
            }
          } else if (state.preview.mode === "event") {
            const matchEvent = state.skyEvents.find((event) => event.id === state.preview.skyEvent?.id);
            if (matchEvent) {
              state.preview.skyEvent = matchEvent;
            } else {
              clearPreview();
            }
          }
        }
        updateNextVisible();
        renderPassList();
        renderSkyEventsList();
        scheduleNotification();
        updateSkyCanvas();
      } catch (error) {
        console.error(error);
      }
    }

    function animateISS() {
      const now = Date.now();
      const sample = interpolateSample(state.issSamples.prev, state.issSamples.next, now);
      if (sample) {
        state.iss = sample;
        updateISSMarker();
        if (now - state.anim.lastStatus > 900) {
          setStatus();
          state.anim.lastStatus = now;
        }
        if (globeViewEl.classList.contains("active")) {
          renderGlobe();
        }
        if (skyViewEl.classList.contains("active")) {
          updateSkyCanvas();
        }
      }
      state.anim.rafId = requestAnimationFrame(animateISS);
    }

    async function setUserLocation(lat, lon, source, persist = true) {
      state.user = { lat, lon, source };
      if (persist) {
        saveUserLocation(lat, lon, source);
      }
      updateUserMarker();
      setStatus();
      await refreshAll();
    }

    document.getElementById("locate").addEventListener("click", () => {
      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          setUserLocation(pos.coords.latitude, pos.coords.longitude, "Device location");
        },
        () => {
          alert("Unable to access your location. You can enter coordinates manually.");
        },
        { enableHighAccuracy: true }
      );
    });

    document.getElementById("apply-coords").addEventListener("click", () => {
      const lat = parseFloat(document.getElementById("lat").value);
      const lon = parseFloat(document.getElementById("lon").value);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        setUserLocation(lat, lon, "Manual coordinates");
      }
    });

    document.getElementById("refresh").addEventListener("click", refreshAll);

    document.getElementById("track-hours").addEventListener("input", (event) => {
      document.getElementById("track-hours-label").textContent = `${event.target.value} hours of orbit path`;
    });

    document.getElementById("track-hours").addEventListener("change", refreshAll);

    document.getElementById("notify").addEventListener("click", async () => {
      if (!("Notification" in window)) {
        alert("This browser does not support notifications.");
        return;
      }
      const permission = await Notification.requestPermission();
      state.notificationsEnabled = permission === "granted";
      if (state.notificationsEnabled) {
        scheduleNotification();
      }
    });

    document.getElementById("preview-exit").addEventListener("click", () => {
      clearPreview();
      setActiveView("sky");
    });

    function setActiveView(view) {
      const isMap = view === "map";
      const isGlobe = view === "globe";
      const isSky = view === "sky";

      document.getElementById("btn-map").classList.toggle("active", isMap);
      document.getElementById("btn-globe").classList.toggle("active", isGlobe);
      document.getElementById("btn-sky").classList.toggle("active", isSky);

      mapEl.classList.toggle("active", isMap);
      globeViewEl.classList.toggle("active", isGlobe);
      skyViewEl.classList.toggle("active", isSky);

      if (isMap && state.map) {
        state.map.invalidateSize();
        syncMapNoWrapZoomConstraints(true);
      }
      if (isGlobe) {
        resizeGlobe();
        renderGlobe();
      }
      if (isSky) {
        updateSkyCanvas();
      }
    }

    document.getElementById("btn-map").addEventListener("click", () => setActiveView("map"));
    document.getElementById("btn-globe").addEventListener("click", () => setActiveView("globe"));
    document.getElementById("btn-sky").addEventListener("click", () => setActiveView("sky"));

    initMap();
    initMapResizing();
    initGlobe();
    initSky();
    clearPreview();
    registerGestureBlocker(mapEl, () => mapEl.classList.contains("active"));
    registerGestureBlocker(globeEl, () => globeViewEl.classList.contains("active"));
    registerGestureBlocker(skyCanvas, () => skyViewEl.classList.contains("active"));
    loadStoredLocation();
    refreshAll();
    animateISS();
    setInterval(fetchISSNow, 6000);
  </script>
</body>
</html>
